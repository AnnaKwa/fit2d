import numpy as np
import time
from typing import Sequence, Callable, Mapping, Union

from .._galaxy import Galaxy, RingModel
from .._velocity_field_generator import create_2d_velocity_field
from ..models import Model

def dynesty_lnlike(lnlike_func, normalization_func, lnlike_args, ):
    return lambda cube: lnlike_func(normalization_func(cube), *lnlike_args)


def emcee_lnlike(params, emcee_version: float, lnlike_args: Union[Mapping, Sequence]):
    # wraps the lnlike function because emcee expects 
    # tuple of (lnlike, blob) returned
    if isinstance(lnlike_args, Sequence):
        lnl = lnlike(params, *lnlike_args), None
    else:
        lnl = lnlike(params, **lnlike_args)
    if emcee_version < 3:
        # older version expects two returns: lnlike and blobs
        return lnl, None
    else:
        return lnl


def chisq_2d(
    vlos_2d_model: np.ndarray,
    vlos_2d_obs: np.ndarray,
    v_err_2d: np.ndarray = None,
    v_err_const: float = 10.0,
):
    """[summary]

    Args:

        vlos_2d_model (np.ndarray): modeled 2D velocity field generated by create_2d_velocity_field
        vlos_2d_obs (np.ndarray): observed2D velocity field
        v_err_2d (np.ndarray, optional): ndarray with values of 2D velocity uncertainty at each pixel.
            If used, should be of same dimensions as modeled velocity field. Defaults to None.
        v_err_const (float, optional): If no ndarray provided for errors at each pixel, use this
            constant value for calculating Chi^2. Defaults to 10 km/s.
        n_interp_r (int, optional): Number of radii to use in constructing modeled field.
            Defaults to 75.
        n_interp_theta (int, optional): Number of azimuthal angles to use in construction modeled field.
            Defaults to 700.

    Returns:
        Chi^2
    """
    if np.shape(vlos_2d_model) != np.shape(vlos_2d_obs):
        raise ValueError(
            f"Shape of modeled velocity field {vlos_2d_model.shape} must "
            f"be equal to shape of observed velocity field {vlos_2d_obs.shape}."
        )
    if v_err_2d:
        chisq = np.nansum((vlos_2d_obs - vlos_2d_model) ** 2 / v_err_2d ** 2)
    else:
        chisq = np.nansum((vlos_2d_obs - vlos_2d_model) ** 2 / v_err_const ** 2)
    return chisq
    

def lnlike(
    params: np.ndarray,
    model: Model,
    rotation_curve_func_kwargs: Mapping,
    galaxy: Galaxy,
    ring_model: RingModel,
    mask_sigma: float = 1.,
    v_err_2d: np.ndarray = None,
    v_err_const: float = 10.0,
    n_interp_r: int = 150,
    n_interp_theta: int = 150,
):
    params = np.array(params)
    v_m = model.generate_1d_rotation_curve(params, **rotation_curve_func_kwargs)
    vlos_2d_model = create_2d_velocity_field(
        radii=ring_model.radii_kpc,
        v_rot=v_m,
        ring_model=ring_model,
        kpc_per_pixel=galaxy.kpc_per_pixel,
        v_systemic=galaxy.v_systemic,
        image_xdim=galaxy.image_xdim,
        image_ydim=galaxy.image_ydim,
        n_interp_r=n_interp_r,
        n_interp_theta=n_interp_theta,
        mask_sigma=mask_sigma,
    )
    chisq = chisq_2d(
        vlos_2d_model=vlos_2d_model,
        vlos_2d_obs=galaxy.observed_2d_vel_field,
        v_err_2d=v_err_2d,
        v_err_const=v_err_const,
    )
    prior = model.tophat_prior(params)
    return -0.5 * chisq + prior

